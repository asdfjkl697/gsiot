//============================================================================
// Name        : video.cpp
// Author      : 
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include <string>
#include <iostream>

#include <linux/videodev2.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <string.h>






struct v4l2_format
{
    enum v4l2_buf_type type;    // 数据流类型，必须永远是//V4L2_BUF_TYPE_VIDEO_CAPTURE
    union
    {
        struct v4l2_pix_format    pix;
        struct v4l2_window        win;
        struct v4l2_vbi_format    vbi;
        __u8    raw_data[200];
    } fmt;
};
struct v4l2_pix_format
{
    __u32                   width;         // 宽，必须是16的倍数
    __u32                   height;        // 高，必须是16的倍数
    __u32                   pixelformat;   // 视频数据存储类型，例如是//YUV4：2：2还是RGB
    enum v4l2_field         field;
    __u32                   bytesperline;
    __u32                   sizeimage;
    enum v4l2_colorspace    colorspace;
    __u32                   priv;
};

struct v4l2_requestbuffers
{
    __u32               count; // 缓存数量，也就是说在缓存队列里保持多少张照片
    enum v4l2_buf_type type;   // 数据流类型，必须永远是V4L2_BUF_TYPE_VIDEO_CAPTURE
    enum v4l2_memory    memory; // V4L2_MEMORY_MMAP 或 V4L2_MEMORY_USERPTR
    __u32               reserved[2];
};

typedef struct VideoBuffer {
    void   *start;
    size_t length;
} VideoBuffer;

int main() {
	int fd;
	fd = open(“/dev/video1″, O_RDWR | O_NONBLOCK, 0);

	v4l2_std_id std;
	int ret;
	do {
		ret = ioctl(fd, VIDIOC_QUERYSTD, &std);
	}while (ret == -1 && errno == EAGAIN);

	switch (std) {
		case V4L2_STD_NTSC:
		//……
		case V4L2_STD_PAL:
		//……
	}

	struct v4l2_format fmt;
	memset ( &fmt, 0, sizeof(fmt) );
	fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	fmt.fmt.pix.width = 720;
	fmt.fmt.pix.height = 576;
	fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;
	fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;
	if (ioctl(fd, VIDIOC_S_FMT, &fmt) == -1) {
		return -1;
	}

	VideoBuffer*          buffers = calloc( req.count, sizeof(*buffers) );
	struct v4l2_buffer    buf;

	for (numBufs = 0; numBufs < req.count; numBufs++) {
	    memset( &buf, 0, sizeof(buf) );
	    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	    buf.memory = V4L2_MEMORY_MMAP;
	    buf.index = numBufs;
	    // 读取缓存
	    if (ioctl(fd, VIDIOC_QUERYBUF, &buf) == -1) {
	        return -1;
	    }
	     buffers[numBufs].length = buf.length;
	    // 转换成相对地址
	    buffers[numBufs].start = mmap(NULL, buf.length,
	        PROT_READ | PROT_WRITE,
	        MAP_SHARED,
	        fd, buf.m.offset);

	    if (buffers[numBufs].start == MAP_FAILED) {
	        return -1;
	    }

	    // 放入缓存队列
	    if (ioctl(fd, VIDIOC_QBUF, &buf) == -1) {
	        return -1;
	    }
	}

	return 0;
}
